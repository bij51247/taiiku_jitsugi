<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>Vue.js カスタムシークバー付き動画プレイヤー</title>
  <style>
    .videos-container {
      display: flex;
      /* Flexboxコンテナにする */
      align-items: flex-start;
      /* アイテムを上端に揃える */
      justify-content: center;
      /* アイテムを中央に揃える */
      gap: 20px;
      /* 動画間の隙間を設定 */
      margin-bottom: 20px;
      /* 下部の要素との間隔を設ける */
    }

    .video-container {
      position: relative;
      width: 320px;
      /* この幅は必要に応じて調整 */
      height: 180px;
      /* この高さは必要に応じて調整 */
      margin-bottom: 30px;
      /* シークバーとファイルアップロードボタン用の余白 */
    }

    .video-box {
      position: relative;
      display: inline-block;
      /* シークバー用のスペースを保持 */
    }

    video {
      width: 100%;
      height: auto;
      display: block;
      transform-origin: center;
      /* ここを追加 */
    }

    .seek-bar {
      width: 100%;
      height: 20px;
      margin-top: 5px;
      /* シークバーの上部余白を設定 */
      background: rgba(0, 0, 0, 0.5);
    }

    .seek-bar input[type="range"] {
      width: 100%;
      height: 100%;
      cursor: pointer;
      background: transparent;
      -webkit-appearance: none;
      /* スライダーのデフォルトスタイリングを削除 */
      appearance: none;
    }

    .seek-bar input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
    }

    .seek-bar input[type="range"]::-moz-range-thumb {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
    }

    /* 追加されたプレースホルダーのスタイル */
    .video-placeholder {
      width: 320px;
      height: 180px;
      background-color: #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      font-size: 20px;
    }

    /* ファイルアップロードボタンのスタイル */
    .file-upload-input {
      margin-top: 10px;
      /* ここで余白を調整できます */
      width: 320px;
      /* video-container と同じ幅 */
    }

    .start-pin {
      position: relative;
      left: 0%;

      width: 5px;
      /* 幅を調整して棒の太さを変更できます */
      height: 30px;
      /* 高さを10pxに設定 */
      top: -30px;
      /* 高さをシークバー全体に広げます */
      background-color: blue;
      /* 色を青に設定 */
    }

    .video-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      /* この行を追加 */
      height: 100%;
      /* この行を追加 */
      background-color: rgba(0, 0, 0, 0.5);
      transition: opacity 0.5s ease;
    }

    .pause-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: white;
      transition: opacity 0.5s ease;
    }

    .video-box {
      position: relative;
      /* 他のスタイルが必要な場合はここに追加 */
      width: 320px;
      /* この幅は必要に応じて調整 */
      height: 180px;
      /* この高さは必要に応じて調整 */
      overflow: hidden;
      /* 範囲外の部分を非表示に */
    }

    .control {
      margin-top: 100px;
    }
  </style>
  <script src="https://unpkg.com/vue@2.6.14/dist/vue.js"></script>
</head>

<body>
  <div id="app">
    <div class="videos-container">
      <!-- もう一丁 -->
      <div class="video-container">
        <div class="video-box">
          <video ref="embeddedVideo" :src="embeddedVideoSrc" @loadedmetadata="initializeSeekBar('embedded')"
            @timeupdate="updateSeekBar('embedded')" :loop="loop" @click="toggleOverlay('embedded')"
            @wheel="handleZoom($event, 'embedded')">
            Your browser does not support HTML5 video.
          </video>
          <div class="video-overlay" v-show="embeddedOverlayVisible"></div>
          <div class="pause-button" v-show="embeddedOverlayVisible" @click="togglePlayPause('embedded')">{{
            isPlaying.embedded ? '⏸️' : '▶️' }}</div>

        </div>
        <div class="seek-bar">
          <input type="range" min="0" :max="embeddedMax" :value="embeddedCurrent"
            @input="setPosition($event, 'embedded')" step="any">
          <div class="start-pin embedded-pin"></div> <!-- ここに新しい要素を追加 -->
        </div>
        <!-- 埋め込み動画用のファイルアップロード部分を追加 -->
        <input type="file" @change="handleEmbeddedFileChange" accept="video/*" class="file-upload-input">
      </div>

      <!-- アップロードされた動画のコンテナ -->
      <div class="video-container">
        <template>
          <div class="video-box">
            <div v-if="!videoSrc" class="video-placeholder">動画をアップロードしてください</div>
            <video ref="uploadedVideo" :src="videoSrc" @loadedmetadata="initializeSeekBar('uploaded')"
              @timeupdate="updateSeekBar('uploaded')" :loop="loop" @click="toggleOverlay('uploaded')"
              @wheel="handleZoom($event, 'uploaded')">
              Your browser does not support HTML5 video.
            </video>
            <div class="video-overlay" v-show="uploadedOverlayVisible"></div>
            <div class="pause-button" v-show="uploadedOverlayVisible" @click="togglePlayPause('uploaded')">{{
              isPlaying.uploaded ? '⏸️' : '▶️' }}</div>

          </div>
          <div class="seek-bar">
            <!-- 動画がない場合はrangeを無効化する -->
            <input type="range" min="0" :max="videoSrc ? uploadedMax : 100" :value="videoSrc ? uploadedCurrent : 0"
              @input="videoSrc && setPosition($event, 'uploaded')" :disabled="!videoSrc" step="any">
            <div class="start-pin uploaded-pin"></div> <!-- ここに新しい要素を追加 -->
          </div>
        </template>
        <input type="file" @change="handleFileChange" accept="video/*" class="file-upload-input">
      </div>
    </div>

    <!-- コントロールボタン -->
    <div style="text-align: center;" class="control">
      <button @click="toggleBothVideos">同時再生/ポーズ</button>
      <label class="switch">
        <input type="checkbox" v-model="loop">
        <span class="slider round"></span>
      </label>
    </div>

    <div style="text-align: center; margin-top: 20px;">
      <label for="speedControl">再生速度:</label>
      <input type="range" id="speedControl" min="0.25" max="2" step="0.25" value="1"
        @input="changePlaybackRate($event)">
    </div>

    <script>
      new Vue({
        el: '#app',
        data: {
          videoSrc: null,
          embeddedCurrent: 0,
          embeddedMax: 0,
          uploadedCurrent: 0,
          uploadedMax: 0,
          embeddedVideoSrc: 'example.mp4', // 埋め込み動画のデフォルトソース
          embeddedStart: 0,
          uploadedStart: 0,
          dragging: false,
          startPinPosition: 0,
          loop: false,
          embeddedOverlayVisible: false,
          uploadedOverlayVisible: false,
          overlayTimeout: null,
          isPlaying: {
            embedded: false,
            uploaded: false
          },
          videoScale: 1, // ビデオの拡大縮小率
        },
        methods: {
          handleFileChange(event) {
            const file = event.target.files[0];
            if (file) {
              this.videoSrc = URL.createObjectURL(file);
              const uploadedVideoPlayer = this.$refs.uploadedVideo;
              if (uploadedVideoPlayer) {
                uploadedVideoPlayer.load();
              }
            }
          },
          toggleBothVideos() {
            const embeddedVideoPlayer = this.$refs.embeddedVideo;
            const uploadedVideoPlayer = this.$refs.uploadedVideo;

            if (embeddedVideoPlayer && uploadedVideoPlayer) {
              if (embeddedVideoPlayer.paused || uploadedVideoPlayer.paused) {
                // 再生位置の設定を削除
                embeddedVideoPlayer.play();
                uploadedVideoPlayer.play();
              } else {
                embeddedVideoPlayer.pause();
                uploadedVideoPlayer.pause();
              }
            }
          },

          handleZoom(event, videoType) {
            const scaleIncrement = 0.1;
            if (event.deltaY < 0) {
              // ホイールアップで拡大
              this.videoScale = Math.min(this.videoScale + scaleIncrement, 3); // 上限を3に設定
            } else {
              // ホイールダウンで縮小
              this.videoScale = Math.max(this.videoScale - scaleIncrement, 1); // 下限を1に設定
            }

            const videoElement = this.$refs[`${videoType}Video`];
            if (videoElement) {
              videoElement.style.transform = `scale(${this.videoScale})`;
              // 拡大縮小後に中央揃えを維持するための追加処理 
              const containerRect = this.$el.querySelector(`.${videoType}-container`).getBoundingClientRect();
              const videoRect = videoElement.getBoundingClientRect();
              const offsetX = (containerRect.width - videoRect.width) / 2;
              const offsetY = (containerRect.height - videoRect.height) / 2;
              videoElement.style.transformOrigin = `${50 - offsetX / this.videoScale}% ${50 - offsetY / this.videoScale}%`;
            }
          },
          handleMouseDown(event, videoType) {
            if (event.button === 1) { // 中ボタンでのドラッグ
              this.isDragging = true;
              this.lastX = event.clientX;
              this.lastY = event.clientY;
              this.activeVideo = videoType;
            }
          },
          handleMouseMove(event) {
            if (this.isDragging) {
              const deltaX = event.clientX - this.lastX;
              const deltaY = event.clientY - this.lastY;
              this.lastX = event.clientX;
              this.lastY = event.clientY;

              this.scrollVideo(deltaX, deltaY, this.activeVideo);
            }
          },
          handleMouseUp(event) {
            if (event.button === 1) {
              this.isDragging = false;
            }
          },

          handleTouchStart(event, videoType) {
            if (event.touches.length === 2) { // 2本指でのタッチ
              this.isDragging = true;
              this.lastX = event.touches[0].clientX;
              this.lastY = event.touches[0].clientY;
              this.activeVideo = videoType;
            }
          },
          handleTouchMove(event) {
            if (this.isDragging && event.touches.length === 2) {
              const deltaX = event.touches[0].clientX - this.lastX;
              const deltaY = event.touches[0].clientY - this.lastY;
              this.lastX = event.touches[0].clientX;
              this.lastY = event.touches[0].clientY;

              this.scrollVideo(deltaX, deltaY, this.activeVideo);
            }
          },

          handleTouchEnd(event) {
            if (this.isDragging && event.touches.length < 2) {
              this.isDragging = false;
            }
          },
          scrollVideo(deltaX, deltaY, videoType) {
            if (this.videoScale <= 1) {
              return; // 拡大率が1倍以下の場合はスクロールしない
            }

            // videoElementとcontainerを取得
            const videoElement = this.$refs[`${videoType}Video`];
            // const container = this.$el.querySelector(`.${videoType}-container`);

            const containerRect = this.$el.querySelector(`.video-box`).getBoundingClientRect();
            const videoRect = videoElement.getBoundingClientRect();


            // 現在の transform スタイルを取得
            const style = window.getComputedStyle(videoElement);
            const transform = style.transform || style.webkitTransform || style.mozTransform;

            let matrix = transform.match(/^matrix\((.+)\)$/);
            let translateX = 0, translateY = 0;
            if (matrix) {
              matrix = matrix[1].split(', ');
              translateX = parseInt(matrix[4]) + deltaX;
              translateY = parseInt(matrix[5]) + deltaY;
            }

            // スクロール範囲の制限
            const scaledWidth = videoRect.width * this.videoScale;
            const scaledHeight = videoRect.height * this.videoScale;
            translateX = Math.min(Math.max(translateX, containerRect.width - scaledWidth), 0);
            translateY = Math.min(Math.max(translateY, containerRect.height - scaledHeight), 0);

            videoElement.style.transform = `matrix(${this.videoScale}, 0, 0, ${this.videoScale}, ${translateX}, ${translateY})`;
          },

          toggleOverlay(videoType) {
            this[`${videoType}OverlayVisible`] = !this[`${videoType}OverlayVisible`];
            clearTimeout(this.overlayTimeout);
            this.overlayTimeout = setTimeout(() => {
              this[`${videoType}OverlayVisible`] = false;
            }, 3000); // 3秒後にフェードアウト
          },
          togglePlayPause(videoType) {
            const videoPlayer = this.$refs[`${videoType}Video`];
            if (!videoPlayer) return;

            if (this.isPlaying[videoType]) {
              videoPlayer.pause();
            } else {
              videoPlayer.play();
            }
            this.isPlaying[videoType] = !this.isPlaying[videoType];
          },
          changePlaybackRate(event) {
            const rate = event.target.value;
            if (this.$refs.embeddedVideo) {
              this.$refs.embeddedVideo.playbackRate = rate;
            }
            if (this.$refs.uploadedVideo) {
              this.$refs.uploadedVideo.playbackRate = rate;
            }
          },
          pauseBothVideos() {
            const embeddedVideoPlayer = this.$refs.embeddedVideo;
            const uploadedVideoPlayer = this.$refs.uploadedVideo;
            if (embeddedVideoPlayer && uploadedVideoPlayer) {
              embeddedVideoPlayer.pause();
              uploadedVideoPlayer.pause();
            }
          },
          updateSeekBar(videoType) {
            const videoPlayer = this.$refs[`${videoType}Video`];
            if (videoPlayer) {
              // スタートピンの位置より前には移動しないようにする
              if (videoPlayer.currentTime < this[`${videoType}Start`] / 100 * videoPlayer.duration) {
                videoPlayer.currentTime = this[`${videoType}Start`] / 100 * videoPlayer.duration;
              }
              this[`${videoType}Current`] = videoPlayer.currentTime;
              this[`${videoType}Max`] = videoPlayer.duration;
            }
          },
          initializeSeekBar(videoType) {
            const videoPlayer = this.$refs[`${videoType}Video`];
            if (videoPlayer) {
              this[`${videoType}Max`] = videoPlayer.duration;
            }
          },
          setPosition(event, videoType) {
            const videoPlayer = this.$refs[`${videoType}Video`];
            const value = event.target.value;
            if (videoPlayer && value != null) {
              videoPlayer.currentTime = value;
            }
          },
          handleEmbeddedFileChange(event) {
            const file = event.target.files[0];
            if (file) {
              this.embeddedVideoSrc = URL.createObjectURL(file);
              const embeddedVideoPlayer = this.$refs.embeddedVideo;
              if (embeddedVideoPlayer) {
                embeddedVideoPlayer.load();
              }
            }
          },
          setStartingPosition(event, videoType) {
            const value = parseFloat(event.target.value);
            this[`${videoType}Start`] = value;
            // Make the video start from the pin's position when played
            const videoPlayer = this.$refs[`${videoType}Video`];
            if (videoPlayer) {
              videoPlayer.currentTime = value;
            }

            // Optionally, if you want the video to start playing immediately from the pin position
            if (!videoPlayer.paused) {
              videoPlayer.play();
            }
          },

          dragStart: function (event) {
            this.dragging = true;
            // ここでは、startPinPosition を設定する代わりに、drag メソッド内で計算を行います。
            this.activePin = event.target.classList.contains('embedded-pin') ? 'embedded' : 'uploaded';
          },
          dragEnd: function () {
            this.dragging = false;
          },
          drag: function (event) {
            if (!this.dragging) return;

            var seekBar = this.activePin === 'embedded'
              ? this.$el.querySelector('.embedded-pin').parentNode
              : this.$el.querySelector('.uploaded-pin').parentNode;
            var seekBarRect = seekBar.getBoundingClientRect();

            var newLeft = (event.clientX - seekBarRect.left) / seekBarRect.width * 100;
            newLeft = Math.min(Math.max(newLeft, 0), 100);

            var startPin = this.activePin === 'embedded'
              ? this.$el.querySelector('.embedded-pin')
              : this.$el.querySelector('.uploaded-pin');
            startPin.style.left = newLeft + '%';

            this[`${this.activePin}Start`] = newLeft;

            const videoPlayer = this.$refs[`${this.activePin}Video`];
            if (videoPlayer) {
              videoPlayer.currentTime = videoPlayer.duration * (newLeft / 100);
              // Update the range input's value as well
              this[`${this.activePin}Current`] = videoPlayer.currentTime;
            }
          }
        },
        mounted: function () {
          var embeddedPin = this.$el.querySelector('.embedded-pin');
          var uploadedPin = this.$el.querySelector('.uploaded-pin');
          embeddedPin.addEventListener('mousedown', this.dragStart);
          uploadedPin.addEventListener('mousedown', this.dragStart);
          document.addEventListener('mousemove', this.drag);
          document.addEventListener('mouseup', this.dragEnd);

          const embeddedVideoElement = this.$refs.embeddedVideo;
          const uploadedVideoElement = this.$refs.uploadedVideo;

          embeddedVideoElement.addEventListener('wheel', (event) => this.handleZoom(event, 'embedded'));
          uploadedVideoElement.addEventListener('wheel', (event) => this.handleZoom(event, 'uploaded'));

          // embeddedVideoElement（埋め込み動画）に対するイベントリスナーを設定
          embeddedVideoElement.addEventListener('mousedown', (event) => this.handleMouseDown(event, 'embedded'));
          embeddedVideoElement.addEventListener('mousemove', (event) => this.handleMouseMove(event, 'embedded'));
          embeddedVideoElement.addEventListener('mouseup', (event) => this.handleMouseUp(event, 'embedded'));
          embeddedVideoElement.addEventListener('touchstart', (event) => this.handleTouchStart(event, 'embedded'), { passive: false });
          embeddedVideoElement.addEventListener('touchmove', (event) => this.handleTouchMove(event, 'embedded'), { passive: false });
          embeddedVideoElement.addEventListener('touchend', (event) => this.handleTouchEnd(event, 'embedded'));

          // uploadedVideoElement（アップロードされた動画）に対するイベントリスナーを設定
          uploadedVideoElement.addEventListener('mousedown', (event) => this.handleMouseDown(event, 'uploaded'));
          uploadedVideoElement.addEventListener('mousemove', (event) => this.handleMouseMove(event, 'uploaded'));
          uploadedVideoElement.addEventListener('mouseup', (event) => this.handleMouseUp(event, 'uploaded'));
          uploadedVideoElement.addEventListener('touchstart', (event) => this.handleTouchStart(event, 'uploaded'), { passive: false });
          uploadedVideoElement.addEventListener('touchmove', (event) => this.handleTouchMove(event, 'uploaded'), { passive: false });
          uploadedVideoElement.addEventListener('touchend', (event) => this.handleTouchEnd(event, 'uploaded'));

          // ドキュメントに対するマウスイベントリスナーを設定
          document.addEventListener('mousemove', this.handleMouseMove);
          document.addEventListener('mouseup', this.handleMouseUp);

          // ドキュメントに対するタッチイベントリスナーを設定
          document.addEventListener('touchmove', this.handleTouchMove, { passive: false });
          document.addEventListener('touchend', this.handleTouchEnd);


        },
        beforeDestroy: function () {
          var embeddedPin = this.$el.querySelector('.embedded-pin');
          var uploadedPin = this.$el.querySelector('.uploaded-pin');
          embeddedPin.removeEventListener('mousedown', this.dragStart);
          uploadedPin.removeEventListener('mousedown', this.dragStart);
          document.removeEventListener('mousemove', this.drag);
          document.removeEventListener('mouseup', this.dragEnd);

          const embeddedVideoElement = this.$refs.embeddedVideo;
          const uploadedVideoElement = this.$refs.uploadedVideo;

          embeddedVideoElement.removeEventListener('wheel', (event) => this.handleZoom(event, 'embedded'));
          uploadedVideoElement.removeEventListener('wheel', (event) => this.handleZoom(event, 'uploaded'));

          // embeddedVideoElement（埋め込み動画）からイベントリスナーを削除
          embeddedVideoElement.removeEventListener('mousedown', (event) => this.handleMouseDown(event, 'embedded'));
          embeddedVideoElement.removeEventListener('mousemove', (event) => this.handleMouseMove(event, 'embedded'));
          embeddedVideoElement.removeEventListener('mouseup', (event) => this.handleMouseUp(event, 'embedded'));
          embeddedVideoElement.removeEventListener('touchstart', (event) => this.handleTouchStart(event, 'embedded'), { passive: false });
          embeddedVideoElement.removeEventListener('touchmove', (event) => this.handleTouchMove(event, 'embedded'), { passive: false });
          embeddedVideoElement.removeEventListener('touchend', (event) => this.handleTouchEnd(event, 'embedded'));

          // uploadedVideoElement（アップロードされた動画）からイベントリスナーを削除
          uploadedVideoElement.removeEventListener('mousedown', (event) => this.handleMouseDown(event, 'uploaded'));
          uploadedVideoElement.removeEventListener('mousemove', (event) => this.handleMouseMove(event, 'uploaded'));
          uploadedVideoElement.removeEventListener('mouseup', (event) => this.handleMouseUp(event, 'uploaded'));
          uploadedVideoElement.removeEventListener('touchstart', (event) => this.handleTouchStart(event, 'uploaded'), { passive: false });
          uploadedVideoElement.removeEventListener('touchmove', (event) => this.handleTouchMove(event, 'uploaded'), { passive: false });
          uploadedVideoElement.removeEventListener('touchend', (event) => this.handleTouchEnd(event, 'uploaded'));

          // ドキュメントからマウスとタッチイベントリスナーを削除
          document.removeEventListener('mousemove', this.handleMouseMove);
          document.removeEventListener('mouseup', this.handleMouseUp);
          document.removeEventListener('touchmove', this.handleTouchMove, { passive: false });
          document.removeEventListener('touchend', this.handleTouchEnd);
        }

      });



    </script>
</body>

</html>